# Few-Shot Learning pro SmartScan

## üìã P≈ôehled konceptu

Few-shot learning umo≈æ≈àuje u≈æivatel≈Øm vytv√°≈ôet vlastn√≠ "koncepty" (nap≈ô. osoby, objekty) pomoc√≠ nƒõkolika p≈ô√≠klad≈Ø (5-10 obr√°zk≈Ø). Syst√©m vytvo≈ô√≠ pr≈Ømƒõrn√Ω embedding z tƒõchto p≈ô√≠klad≈Ø a ulo≈æ√≠ jej jako "prototype", kter√Ω pak lze pou≈æ√≠t pro vyhled√°v√°n√≠.

### P≈ô√≠klad Use Case:
```
1. U≈æivatel vybere 10 fotek dcery Barunky
2. U ka≈æd√© o≈ô√≠zne obliƒçej pomoc√≠ crop n√°stroje
3. Syst√©m vytvo≈ô√≠ embeddingy v≈°ech crop≈Ø
4. Spoƒç√≠t√° pr≈Ømƒõrn√Ω embedding ‚Üí "Barunka prototype"
5. Ulo≈æ√≠ jako Few-Shot Tag "Barunka"

Pot√© m≈Ø≈æe vyhled√°vat:
- "Barunka" (jen prototype)
- "Barunka v lese" (prototype + text)
- "Barunka a Jonasek" (2 prototypes + text)
```

## üéØ Teoretick√Ω z√°klad

### Jak funguje Few-Shot Learning:

```
Few-Shot Tag "Barunka":
‚îú‚îÄ‚îÄ Sample 1: [0.23, 0.45, 0.12, ...] (768 dim embedding)
‚îú‚îÄ‚îÄ Sample 2: [0.21, 0.47, 0.10, ...]
‚îú‚îÄ‚îÄ Sample 3: [0.24, 0.43, 0.14, ...]
‚îú‚îÄ‚îÄ Sample 4: [0.22, 0.46, 0.11, ...]
‚îú‚îÄ‚îÄ Sample 5: [0.25, 0.44, 0.13, ...]
‚îî‚îÄ‚îÄ Prototype: [0.23, 0.45, 0.12, ...] ‚Üí Pr≈Ømƒõr v≈°ech samplu

Search query: "Barunka a Jonasek v lese"
‚îú‚îÄ‚îÄ Text embedding: "v lese" ‚Üí [0.8, 0.3, 0.5, ...]
‚îú‚îÄ‚îÄ Prototype 1: "Barunka" ‚Üí [0.23, 0.45, 0.12, ...]
‚îú‚îÄ‚îÄ Prototype 2: "Jonasek" ‚Üí [0.15, 0.52, 0.08, ...]
‚îî‚îÄ‚îÄ Combined embedding: Average nebo weighted sum ‚Üí Final search vector
```

### Proƒç to funguje:

1. **Semantic averaging** - pr≈Ømƒõr podobn√Ωch embedding≈Ø zachov√°v√° sd√≠len√© rysy
2. **Noise reduction** - pr≈Ømƒõrov√°n√≠ potlaƒçuje n√°hodn√© variace
3. **Generalizace** - prototype reprezentuje "esenci" konceptu
4. **Composition** - embeddingy lze kombinovat (Barunka + les + Jonasek)

## üóÑÔ∏è Datab√°zov√° struktura

### Nov√© tabulky:

```kotlin
/**
 * Tabulka pro few-shot prototypes
 *
 * Obsahuje pr≈Ømƒõrn√© embeddingy vytvo≈ôen√© z multiple samplu.
 * Ka≈æd√Ω prototype reprezentuje jeden "koncept" (osobu, objekt, styl).
 */
@Entity(tableName = "few_shot_prototypes")
data class FewShotPrototypeEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    val name: String,                    // "Barunka", "Jonasek", "Moje auto"
    val embedding: FloatArray,           // Pr≈Ømƒõrn√Ω embedding (768 dim pro CLIP)
    val color: Int,                      // Barva pro UI (hex)
    val sampleCount: Int,                // Poƒçet samplu pou≈æit√Ωch pro pr≈Ømƒõr

    val createdAt: Long,                 // Timestamp vytvo≈ôen√≠
    val updatedAt: Long,                 // Timestamp posledn√≠ √∫pravy

    // Metadata
    val description: String? = null,     // Voliteln√Ω popis
    val category: String? = null         // "person", "object", "scene", "style"
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as FewShotPrototypeEntity
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()
}

/**
 * Tabulka pro jednotliv√© sample embeddingy
 *
 * Ukl√°d√° jednotliv√© p≈ô√≠klady pou≈æit√© pro vytvo≈ôen√≠ prototype.
 * Umo≈æ≈àuje re-compute pr≈Ømƒõru p≈ôi p≈ôid√°n√≠/odebr√°n√≠ samplu.
 */
@Entity(
    tableName = "few_shot_samples",
    foreignKeys = [
        ForeignKey(
            entity = FewShotPrototypeEntity::class,
            parentColumns = ["id"],
            childColumns = ["prototypeId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["prototypeId"])]
)
data class FewShotSampleEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    val prototypeId: Long,               // FK to FewShotPrototypeEntity

    val imageUri: String,                // URI p≈Øvodn√≠ho obr√°zku
    val cropRect: String,                // JSON: {"left": 100, "top": 200, "width": 300, "height": 400}
    val embedding: FloatArray,           // Embedding tohoto konkr√©tn√≠ho cropu

    val addedAt: Long,                   // Timestamp p≈ôid√°n√≠

    // Metadata
    val thumbnailPath: String? = null    // Path k thumbnail cropu (pro UI)
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as FewShotSampleEntity
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()
}
```

### Room DAO:

```kotlin
@Dao
interface FewShotPrototypeDao {
    @Query("SELECT * FROM few_shot_prototypes ORDER BY updatedAt DESC")
    fun getAllPrototypes(): Flow<List<FewShotPrototypeEntity>>

    @Query("SELECT * FROM few_shot_prototypes WHERE id = :id")
    suspend fun getPrototypeById(id: Long): FewShotPrototypeEntity?

    @Query("SELECT * FROM few_shot_prototypes WHERE name LIKE '%' || :query || '%'")
    suspend fun searchPrototypes(query: String): List<FewShotPrototypeEntity>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPrototype(prototype: FewShotPrototypeEntity): Long

    @Update
    suspend fun updatePrototype(prototype: FewShotPrototypeEntity)

    @Delete
    suspend fun deletePrototype(prototype: FewShotPrototypeEntity)

    @Query("DELETE FROM few_shot_prototypes WHERE id = :id")
    suspend fun deletePrototypeById(id: Long)
}

@Dao
interface FewShotSampleDao {
    @Query("SELECT * FROM few_shot_samples WHERE prototypeId = :prototypeId ORDER BY addedAt ASC")
    fun getSamplesForPrototype(prototypeId: Long): Flow<List<FewShotSampleEntity>>

    @Query("SELECT COUNT(*) FROM few_shot_samples WHERE prototypeId = :prototypeId")
    suspend fun getSampleCount(prototypeId: Long): Int

    @Insert
    suspend fun insertSample(sample: FewShotSampleEntity): Long

    @Delete
    suspend fun deleteSample(sample: FewShotSampleEntity)

    @Query("DELETE FROM few_shot_samples WHERE id = :id")
    suspend fun deleteSampleById(id: Long)

    @Query("DELETE FROM few_shot_samples WHERE prototypeId = :prototypeId")
    suspend fun deleteAllSamplesForPrototype(prototypeId: Long)
}
```

### Repository:

```kotlin
class FewShotRepository(
    private val prototypeDao: FewShotPrototypeDao,
    private val sampleDao: FewShotSampleDao,
    private val imageEmbedder: ClipImageEmbedder
) {
    val allPrototypes: Flow<List<FewShotPrototypeEntity>> = prototypeDao.getAllPrototypes()

    suspend fun createPrototype(
        name: String,
        color: Int,
        samples: List<Pair<String, String>>, // (imageUri, cropRect)
        description: String? = null,
        category: String? = null
    ): Long {
        // 1. Extract embeddings from all samples
        val embeddings = samples.map { (uri, cropRect) ->
            extractEmbeddingFromCrop(uri, cropRect)
        }

        // 2. Compute average embedding
        val avgEmbedding = computeAverageEmbedding(embeddings)

        // 3. Create prototype
        val prototype = FewShotPrototypeEntity(
            name = name,
            embedding = avgEmbedding,
            color = color,
            sampleCount = samples.size,
            createdAt = System.currentTimeMillis(),
            updatedAt = System.currentTimeMillis(),
            description = description,
            category = category
        )
        val prototypeId = prototypeDao.insertPrototype(prototype)

        // 4. Save individual samples
        samples.forEachIndexed { index, (uri, cropRect) ->
            val sample = FewShotSampleEntity(
                prototypeId = prototypeId,
                imageUri = uri,
                cropRect = cropRect,
                embedding = embeddings[index],
                addedAt = System.currentTimeMillis()
            )
            sampleDao.insertSample(sample)
        }

        return prototypeId
    }

    suspend fun addSampleToPrototype(
        prototypeId: Long,
        imageUri: String,
        cropRect: String
    ) {
        // 1. Extract embedding from new sample
        val embedding = extractEmbeddingFromCrop(imageUri, cropRect)

        // 2. Add sample to DB
        val sample = FewShotSampleEntity(
            prototypeId = prototypeId,
            imageUri = imageUri,
            cropRect = cropRect,
            embedding = embedding,
            addedAt = System.currentTimeMillis()
        )
        sampleDao.insertSample(sample)

        // 3. Re-compute prototype average
        recomputePrototype(prototypeId)
    }

    suspend fun removeSampleFromPrototype(sampleId: Long, prototypeId: Long) {
        sampleDao.deleteSampleById(sampleId)
        recomputePrototype(prototypeId)
    }

    private suspend fun recomputePrototype(prototypeId: Long) {
        val prototype = prototypeDao.getPrototypeById(prototypeId) ?: return
        val samples = sampleDao.getSamplesForPrototype(prototypeId).first()

        if (samples.isEmpty()) {
            // Pokud nejsou ≈æ√°dn√© samples, smazat prototype
            prototypeDao.deletePrototypeById(prototypeId)
            return
        }

        val avgEmbedding = computeAverageEmbedding(samples.map { it.embedding })
        val updatedPrototype = prototype.copy(
            embedding = avgEmbedding,
            sampleCount = samples.size,
            updatedAt = System.currentTimeMillis()
        )
        prototypeDao.updatePrototype(updatedPrototype)
    }

    private suspend fun extractEmbeddingFromCrop(
        imageUri: String,
        cropRectJson: String
    ): FloatArray {
        // Parse crop rect
        val cropRect = parseCropRect(cropRectJson)

        // Load and crop image
        val bitmap = loadAndCropImage(imageUri, cropRect)

        // Extract embedding
        return imageEmbedder.embed(bitmap)
    }

    private fun computeAverageEmbedding(embeddings: List<FloatArray>): FloatArray {
        if (embeddings.isEmpty()) throw IllegalArgumentException("No embeddings to average")

        val dimension = embeddings[0].size
        val sum = FloatArray(dimension) { 0f }

        embeddings.forEach { embedding ->
            for (i in embedding.indices) {
                sum[i] += embedding[i]
            }
        }

        return sum.map { it / embeddings.size }.toFloatArray()
    }

    suspend fun searchPrototypes(query: String): List<FewShotPrototypeEntity> {
        return prototypeDao.searchPrototypes(query)
    }

    suspend fun deletePrototype(prototypeId: Long) {
        prototypeDao.deletePrototypeById(prototypeId)
        // Samples se sma≈æou automaticky (CASCADE)
    }
}
```

## üé® UI Implementace

### 1. Nov√° Tab "Few-Shot Tags"

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Few-Shot Tags                    [+ New Tag]   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ üü£ Barunka                     (12 samples)‚îÇ ‚îÇ
‚îÇ  ‚îÇ    Osoba ‚Ä¢ Vytvo≈ôeno 15.1.2025            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    [üëÅÔ∏è View] [‚úèÔ∏è Edit] [üîç Search] [üóëÔ∏è]  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ üîµ Jonasek                      (8 samples)‚îÇ ‚îÇ
‚îÇ  ‚îÇ    Osoba ‚Ä¢ Vytvo≈ôeno 14.1.2025            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    [üëÅÔ∏è View] [‚úèÔ∏è Edit] [üîç Search] [üóëÔ∏è]  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ üü¢ Amily                        (5 samples)‚îÇ ‚îÇ
‚îÇ  ‚îÇ    Osoba ‚Ä¢ Vytvo≈ôeno 13.1.2025            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    [üëÅÔ∏è View] [‚úèÔ∏è Edit] [üîç Search] [üóëÔ∏è]  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ üü† Moje auto                    (7 samples)‚îÇ ‚îÇ
‚îÇ  ‚îÇ    Objekt ‚Ä¢ Vytvo≈ôeno 10.1.2025           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    [üëÅÔ∏è View] [‚úèÔ∏è Edit] [üîç Search] [üóëÔ∏è]  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. Create/Edit Few-Shot Tag Dialog

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Nov√Ω Few-Shot Tag                    [‚úï]       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  N√°zev:                                         ‚îÇ
‚îÇ  [Barunka_____________________________]         ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  Kategorie:                                     ‚îÇ
‚îÇ  [Person ‚ñº] (Person, Object, Scene, Style)     ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  Barva:                                         ‚îÇ
‚îÇ  üî¥ üü† üü° üü¢ üîµ üü£ üü§ ‚ö´ ‚ö™                       ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  Popis (voliteln√©):                            ‚îÇ
‚îÇ  [Moje dcera Barunka_________________]         ‚îÇ
‚îÇ                                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Samples (3/10):                               ‚îÇ
‚îÇ  Doporuƒçeno 5-10 p≈ô√≠klad≈Ø pro nejlep≈°√≠ v√Ωsledky‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ         ‚îÇ         ‚îÇ         ‚îÇ         ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  IMG 1  ‚îÇ  IMG 2  ‚îÇ  IMG 3  ‚îÇ   [+]   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ         ‚îÇ         ‚îÇ         ‚îÇ  Add    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  [üóëÔ∏è]   ‚îÇ  [üóëÔ∏è]   ‚îÇ  [üóëÔ∏è]   ‚îÇ  More   ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  [üì∑ Take Photo]  [üñºÔ∏è Pick from Gallery]       ‚îÇ
‚îÇ                                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                       [Cancel]  [Create Tag]    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 3. Add Sample Flow

```
User Journey:
1. Klikne na "Pick from Gallery"
2. Vybere obr√°zek
3. Zobraz√≠ se CropImageDialog (existuj√≠c√≠ komponent!)
4. U≈æivatel vybere oblast (obliƒçej, objekt)
5. Klikne "Crop and Add"
6. Thumbnail cropu se zobraz√≠ v sample gridu
7. Embedding se extrahuje na pozad√≠
8. Opakuje pro dal≈°√≠ samples (5-10√ó)
9. Klikne "Create Tag"
10. Syst√©m spoƒç√≠t√° pr≈Ømƒõrn√Ω embedding a ulo≈æ√≠ prototype
```

### 4. View Prototype Detail

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚Üê Barunka                             [‚úèÔ∏è Edit]‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  üü£ Barunka                                     ‚îÇ
‚îÇ  Person ‚Ä¢ 12 samples                            ‚îÇ
‚îÇ  Created: 15.1.2025 14:30                      ‚îÇ
‚îÇ  Updated: 20.1.2025 10:15                      ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  Description:                                   ‚îÇ
‚îÇ  Moje dcera Barunka                            ‚îÇ
‚îÇ                                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Samples:                                       ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê                             ‚îÇ
‚îÇ  ‚îÇ 1 ‚îÇ 2 ‚îÇ 3 ‚îÇ 4 ‚îÇ                             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê                             ‚îÇ
‚îÇ  ‚îÇ 5 ‚îÇ 6 ‚îÇ 7 ‚îÇ 8 ‚îÇ                             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê                             ‚îÇ
‚îÇ  ‚îÇ 9 ‚îÇ10 ‚îÇ11 ‚îÇ12 ‚îÇ                             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò                             ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  [+ Add More Samples]                          ‚îÇ
‚îÇ                                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Actions:                                       ‚îÇ
‚îÇ  [üîç Search with this tag]                     ‚îÇ
‚îÇ  [üì§ Export tag]                               ‚îÇ
‚îÇ  [üóëÔ∏è Delete tag]                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5. Search UI s Few-Shot Integration

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Search                                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  Few-Shot Tags:                                ‚îÇ
‚îÇ  [üü£ Barunka] [üîµ Jonasek] [üü¢ Amily] [+ More] ‚îÇ
‚îÇ       ‚úì             ‚úì                          ‚îÇ
‚îÇ   (selected)    (selected)                     ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  Text Query:                                    ‚îÇ
‚îÇ  [v lese_____________________________] üîç       ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ   ‚îÇ
‚îÇ  Combined Search:                              ‚îÇ
‚îÇ  üü£ Barunka + üîµ Jonasek + "v lese"            ‚îÇ
‚îÇ  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ   ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  [Similarity: 70% ‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]        ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  Results (47):                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ IMG 1 ‚îÇ IMG 2 ‚îÇ IMG 3 ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ  95%  ‚îÇ  92%  ‚îÇ  88%  ‚îÇ                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 6. Autocomplete/Suggestions

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Search                                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  [Bar_____________________________] üîç          ‚îÇ
‚îÇ   ‚Üì                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ  ‚îÇ üü£ Barunka (Few-Shot Tag)       ‚îÇ           ‚îÇ
‚îÇ  ‚îÇ üèñÔ∏è beach (Text)                 ‚îÇ           ‚îÇ
‚îÇ  ‚îÇ üöó car (Text)                   ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üî¨ Embedding Combination Strategies

### Strategie A: Simple Average (DOPORUƒåENO PRO START)

```kotlin
/**
 * Simple averaging - nejjednodu≈°≈°√≠ a p≈ôekvapivƒõ efektivn√≠ p≈ô√≠stup
 *
 * V√Ωhody:
 * - Jednoduch√° implementace
 * - Funguje dob≈ôe v praxi
 * - Rychl√©
 *
 * Nev√Ωhody:
 * - V≈°echny komponenty maj√≠ stejnou v√°hu
 * - M≈Ø≈æe "rozmƒõlnit" d≈Øle≈æit√© rysy
 */
fun combineEmbeddingsSimple(
    prototypes: List<FloatArray>,
    textEmbedding: FloatArray?
): FloatArray {
    val all = prototypes + listOfNotNull(textEmbedding)
    if (all.isEmpty()) throw IllegalArgumentException("No embeddings to combine")

    val dimension = all[0].size
    val sum = FloatArray(dimension) { 0f }

    all.forEach { embedding ->
        for (i in embedding.indices) {
            sum[i] += embedding[i]
        }
    }

    return sum.map { it / all.size }.toFloatArray()
}

// Pou≈æit√≠:
val combined = combineEmbeddingsSimple(
    prototypes = listOf(barunkaEmbedding, jonasekEmbedding),
    textEmbedding = textEmbedder.embed("v lese")
)
```

### Strategie B: Weighted Average

```kotlin
/**
 * Weighted averaging - r≈Øzn√© v√°hy pro r≈Øzn√© komponenty
 *
 * V√Ωhody:
 * - Kontrola d≈Øle≈æitosti ka≈æd√© komponenty
 * - M≈Ø≈æeme zv√Ωhodnit prototype nebo text
 *
 * Nev√Ωhody:
 * - Pot≈ôeba tuning vah
 * - Slo≈æitƒõj≈°√≠
 *
 * Doporuƒçen√© v√°hy:
 * - Prototypes: 0.6-0.7 celkem (rozdƒõleno mezi v≈°echny prototypes)
 * - Text: 0.3-0.4
 */
fun combineEmbeddingsWeighted(
    prototypes: List<FloatArray>,
    textEmbedding: FloatArray?,
    prototypeWeight: Float = 0.7f,
    textWeight: Float = 0.3f
): FloatArray {
    require(prototypeWeight + textWeight == 1.0f) { "Weights must sum to 1.0" }

    val dimension = prototypes[0].size
    val result = FloatArray(dimension) { 0f }

    // Weighted sum of prototypes
    val prototypeWeightEach = if (prototypes.isNotEmpty()) prototypeWeight / prototypes.size else 0f
    prototypes.forEach { prototype ->
        for (i in prototype.indices) {
            result[i] += prototype[i] * prototypeWeightEach
        }
    }

    // Weighted sum of text
    textEmbedding?.let { text ->
        for (i in text.indices) {
            result[i] += text[i] * textWeight
        }
    }

    return result
}

// Pou≈æit√≠:
val combined = combineEmbeddingsWeighted(
    prototypes = listOf(barunkaEmbedding, jonasekEmbedding),
    textEmbedding = textEmbedder.embed("v lese"),
    prototypeWeight = 0.7f,  // 70% v√°ha pro prototypes
    textWeight = 0.3f        // 30% v√°ha pro text
)
```

### Strategie C: Multi-Vector Search (Nejv√≠ce accurate, ale pomalej≈°√≠)

```kotlin
/**
 * Multi-vector search - ka≈æd√Ω prototype hled√° samostatnƒõ
 *
 * V√Ωhody:
 * - Nejp≈ôesnƒõj≈°√≠ v√Ωsledky
 * - Najde obr√°zky kter√© obsahuj√≠ V≈†ECHNY prototypes
 *
 * Nev√Ωhody:
 * - Pomalej≈°√≠ (N √ó v√≠ce v√Ωpoƒçt≈Ø)
 * - Slo≈æitƒõj≈°√≠ ranking
 *
 * Princip:
 * 1. Pro ka≈æd√Ω prototype spoƒç√≠tej similarity se v≈°emi obr√°zky
 * 2. Kombinuj scores pomoc√≠ AND nebo OR logiky
 * 3. Filter podle textu pokud je zad√°n
 */
fun multiVectorSearch(
    imageStore: ImageStore,
    prototypes: List<FloatArray>,
    textEmbedding: FloatArray?,
    threshold: Float = 0.2f,
    combineMode: CombineMode = CombineMode.AND
): List<Pair<Uri, Float>> {
    // 1. Pro ka≈æd√Ω prototype najdi matches
    val prototypeMatches = prototypes.map { prototype ->
        imageStore.search(prototype, threshold)
    }

    // 2. Kombinuj v√Ωsledky
    val combinedMatches = when (combineMode) {
        CombineMode.AND -> {
            // Pr≈Ønik - obr√°zek mus√≠ matchovat V≈†ECHNY prototypes
            prototypeMatches.reduce { acc, matches ->
                acc.filter { (uri, _) ->
                    matches.any { it.first == uri }
                }.map { (uri, score) ->
                    // Average score z v≈°ech matches
                    val otherScore = matches.first { it.first == uri }.second
                    uri to (score + otherScore) / 2
                }
            }
        }
        CombineMode.OR -> {
            // Sjednocen√≠ - obr√°zek staƒç√≠ matchovat JAK√ùKOLIV prototype
            prototypeMatches.flatten()
                .groupBy { it.first }
                .map { (uri, scores) ->
                    // Max score
                    uri to scores.maxOf { it.second }
                }
        }
        CombineMode.WEIGHTED_OR -> {
            // Weighted sum - obr√°zky matchuj√≠c√≠ v√≠ce prototypes maj√≠ vy≈°≈°√≠ score
            prototypeMatches.flatten()
                .groupBy { it.first }
                .map { (uri, scores) ->
                    // Average of all matches
                    uri to scores.map { it.second }.average().toFloat()
                }
        }
    }

    // 3. Filter podle textu pokud je zad√°n
    val finalMatches = if (textEmbedding != null) {
        combinedMatches.filter { (uri, _) ->
            val imgEmbedding = imageStore.getEmbedding(uri)
            cosineSimilarity(imgEmbedding, textEmbedding) >= threshold
        }
    } else {
        combinedMatches
    }

    return finalMatches.sortedByDescending { it.second }
}

enum class CombineMode {
    AND,           // Obr√°zek mus√≠ matchovat V≈†ECHNY prototypes
    OR,            // Obr√°zek staƒç√≠ matchovat JAK√ùKOLIV prototype
    WEIGHTED_OR    // Obr√°zky matchuj√≠c√≠ v√≠ce prototypes maj√≠ vy≈°≈°√≠ prioritu
}
```

### Strategie D: Adaptive Weighting (Advanced)

```kotlin
/**
 * Adaptive weighting - v√°hy se mƒõn√≠ podle kontextu
 *
 * V√Ωhody:
 * - Inteligentn√≠ balancing
 * - P≈ôizp≈Øsob√≠ se specifiƒçnosti query
 *
 * Nev√Ωhody:
 * - Komplexn√≠
 * - Pot≈ôeba experimentov√°n√≠
 *
 * Princip:
 * - Pokud text je velmi specifick√Ω ("v lese na ja≈ôe za de≈°tƒõ"),
 *   zv√Ω≈°it jeho v√°hu
 * - Pokud je jen jeden prototype, zv√Ω≈°it jeho v√°hu
 * - Pokud jsou prototypes velmi podobn√©, sn√≠≈æit jejich v√°hu
 */
fun combineEmbeddingsAdaptive(
    prototypes: List<FloatArray>,
    textEmbedding: FloatArray?,
    textQuery: String?
): FloatArray {
    // Analyze text specificity
    val textSpecificity = textQuery?.split(" ")?.size ?: 0
    val textWeight = when {
        textSpecificity == 0 -> 0f
        textSpecificity <= 2 -> 0.2f
        textSpecificity <= 4 -> 0.3f
        else -> 0.4f
    }

    // Analyze prototype diversity
    val prototypeDiversity = if (prototypes.size > 1) {
        computePrototypeDiversity(prototypes)
    } else {
        1.0f
    }

    // Adjust prototype weight based on diversity
    val prototypeWeight = (1.0f - textWeight) * prototypeDiversity

    return combineEmbeddingsWeighted(
        prototypes = prototypes,
        textEmbedding = textEmbedding,
        prototypeWeight = prototypeWeight,
        textWeight = textWeight
    )
}

fun computePrototypeDiversity(prototypes: List<FloatArray>): Float {
    if (prototypes.size <= 1) return 1.0f

    // Compute pairwise similarities
    val similarities = mutableListOf<Float>()
    for (i in prototypes.indices) {
        for (j in i + 1 until prototypes.size) {
            similarities.add(cosineSimilarity(prototypes[i], prototypes[j]))
        }
    }

    // Average similarity
    val avgSimilarity = similarities.average().toFloat()

    // Diversity = 1 - similarity
    // If prototypes are very similar (avg sim = 0.9), diversity = 0.1
    // If prototypes are very different (avg sim = 0.1), diversity = 0.9
    return 1.0f - avgSimilarity
}
```

## üìä Implementaƒçn√≠ f√°ze

### F√°ze 1: Core Infrastructure (T√Ωden 1)

**C√≠l:** Funkƒçn√≠ datab√°ze a z√°kladn√≠ logika

```
√ökoly:
‚òê Vytvo≈ôit FewShotPrototypeEntity a FewShotSampleEntity
‚òê Vytvo≈ôit FewShotPrototypeDao a FewShotSampleDao
‚òê Vytvo≈ôit FewShotRepository s metodami:
  - createPrototype()
  - addSampleToPrototype()
  - removeSampleFromPrototype()
  - recomputePrototype()
  - deletePrototype()
‚òê P≈ôidat Room migration (DATABASE_VERSION++)
‚òê Unit testy pro repository
‚òê Integration testy pro DB operace

Testovac√≠ krit√©ria:
‚úì Lze vytvo≈ôit prototype z 5 samplu
‚úì Pr≈Ømƒõrn√Ω embedding se spr√°vnƒõ spoƒç√≠t√°
‚úì P≈ôid√°n√≠/odebr√°n√≠ samplu re-compute prototype
‚úì Cascade delete funguje (sample ‚Üí prototype)
```

### F√°ze 2: UI Components (T√Ωden 2)

**C√≠l:** Funkƒçn√≠ UI pro spr√°vu few-shot tag≈Ø

```
√ökoly:
‚òê Vytvo≈ôit FewShotTagsScreen (nov√° tab)
  - Seznam prototypes s preview
  - Search bar pro filtering
  - Sort options (date, name, sample count)
‚òê Vytvo≈ôit CreateFewShotTagDialog
  - Input fields (name, category, color, description)
  - Sample grid
  - Add/remove sample buttons
‚òê Vytvo≈ôit FewShotSamplePicker
  - Integrace s ImagePicker
  - Reuse CropImageDialog
  - Progress indicator p≈ôi extrakci embeddings
‚òê Vytvo≈ôit FewShotPrototypeDetailScreen
  - View samples
  - Edit metadata
  - Add more samples
  - Delete prototype
‚òê ViewModel pro FewShotTags
  - State management
  - Loading states
  - Error handling

Testovac√≠ krit√©ria:
‚úì Lze vytvo≈ôit nov√Ω tag s 5 samples
‚úì Lze zobrazit detail tagu
‚úì Lze p≈ôidat dal≈°√≠ samples do existuj√≠c√≠ho tagu
‚úì Lze smazat tag
‚úì Loading indicators zobrazeny bƒõhem zpracov√°n√≠
```

### F√°ze 3: Search Integration (T√Ωden 3)

**C√≠l:** Few-shot tagy pou≈æiteln√© ve vyhled√°v√°n√≠

```
√ökoly:
‚òê Upravit SearchViewModel:
  - P≈ôidat selectedFewShotPrototypes: StateFlow<Set<Long>>
  - P≈ôidat toggleFewShotPrototype(id: Long)
  - Upravit textSearch() a imageSearch() pro kombinaci embedding≈Ø
‚òê Vytvo≈ôit EmbeddingCombiner
  - Implementovat simple average strategii
  - P≈ôidat weighted average (s konfigurovatelnou v√°hou)
  - Unit testy pro kombinace
‚òê Upravit SearchScreen:
  - FewShotChips horizontal scroll
  - Indicator vybran√Ωch tag≈Ø
  - "Combined search" preview
‚òê Implementovat autocomplete:
  - Suggestions z few-shot tag≈Ø
  - Rank podle shody s query
  - Mix s text suggestions

Testovac√≠ krit√©ria:
‚úì Lze vybrat few-shot tag v search UI
‚úì Search s 1 prototype funguje
‚úì Search s 2+ prototypes funguje
‚úì Kombinace prototype + text funguje
‚úì Autocomplete navrhuje few-shot tagy
```

### F√°ze 4: Advanced Features (T√Ωden 4)

**C√≠l:** Vylep≈°en√≠ UX a pokroƒçil√© funkce

```
√ökoly:
‚òê Multi-vector search (voliteln√° strategie)
‚òê Export/Import few-shot tag≈Ø
  - JSON format
  - Share p≈ôes Intent
  - Import z JSON
‚òê Auto-clustering podobn√Ωch obliƒçej≈Ø
  - Batch process v≈°ech obr√°zk≈Ø
  - Cluster embeddingy pomoc√≠ K-means
  - Nab√≠dnout vytvo≈ôen√≠ few-shot tagu pro cluster
‚òê Confidence scoring
  - Zobrazit similarity score pro ka≈æd√Ω result
  - Color-code podle confidence (zelen√° = high, ≈ælut√° = medium, ƒçerven√° = low)
‚òê Negative prototypes (advanced)
  - "Ne Barunka" - exclude podobn√© obr√°zky
  - Implementace: invertovat similarity nebo odeƒç√≠st od v√Ωsledku
‚òê Analytics
  - Track pou≈æit√≠ few-shot tag≈Ø
  - Nejpou≈æ√≠vanƒõj≈°√≠ tagy
  - Success rate (kolik result≈Ø vrac√≠)

Testovac√≠ krit√©ria:
‚úì Multi-vector search vrac√≠ p≈ôesnƒõj≈°√≠ v√Ωsledky
‚úì Lze exportovat tag jako JSON
‚úì Lze importovat tag z JSON
‚úì Auto-clustering navrhuje relevantn√≠ clustery
‚úì Confidence scores spr√°vnƒõ zobrazeny
```

### F√°ze 5: Polish & Optimization (T√Ωden 5)

**C√≠l:** Performance a UX vylep≈°en√≠

```
√ökoly:
‚òê Performance optimalizace:
  - Cache computed embeddings
  - Batch processing p≈ôi vytv√°≈ôen√≠ tag≈Ø
  - Lazy loading thumbnail≈Ø
  - Background processing pro re-compute
‚òê UX vylep≈°en√≠:
  - Empty states
  - Error states s recovery akcemi
  - Onboarding tutorial
  - Tooltips a n√°povƒõda
‚òê Accessibility:
  - Content descriptions
  - Keyboard navigation
  - Screen reader support
‚òê Testing:
  - UI tests pro v≈°echny screens
  - Integration tests pro complete flow
  - Performance tests (time to create prototype)
‚òê Documentation:
  - User guide
  - Developer docs
  - API documentation

Testovac√≠ krit√©ria:
‚úì Vytvo≈ôen√≠ tagu s 10 samples < 5 sekund
‚úì Search s few-shot tagem < 500ms
‚úì UI reaguje plynule (60 FPS)
‚úì V≈°echny screens maj√≠ empty/error states
‚úì Accessibility score > 90%
```

## üß™ Testing Strategy

### Unit Tests

```kotlin
@Test
fun `computeAverageEmbedding spr√°vnƒõ pr≈Ømƒõruje embeddingy`() {
    val emb1 = floatArrayOf(1f, 2f, 3f)
    val emb2 = floatArrayOf(3f, 4f, 5f)
    val emb3 = floatArrayOf(2f, 3f, 4f)

    val avg = computeAverageEmbedding(listOf(emb1, emb2, emb3))

    assertArrayEquals(floatArrayOf(2f, 3f, 4f), avg, 0.001f)
}

@Test
fun `combineEmbeddingsSimple kombinuje prototypes a text`() {
    val prototype1 = floatArrayOf(1f, 0f, 0f)
    val prototype2 = floatArrayOf(0f, 1f, 0f)
    val text = floatArrayOf(0f, 0f, 1f)

    val combined = combineEmbeddingsSimple(
        listOf(prototype1, prototype2),
        text
    )

    // (1+0+0)/3 = 0.33, (0+1+0)/3 = 0.33, (0+0+1)/3 = 0.33
    assertArrayEquals(floatArrayOf(0.33f, 0.33f, 0.33f), combined, 0.01f)
}

@Test
fun `recomputePrototype aktualizuje pr≈Ømƒõr p≈ôi p≈ôid√°n√≠ samplu`() = runTest {
    // Setup
    val prototypeId = repository.createPrototype(
        name = "Test",
        color = 0xFF0000,
        samples = listOf(
            "uri1" to "crop1",
            "uri2" to "crop2"
        )
    )

    val originalPrototype = repository.getPrototypeById(prototypeId)!!

    // Add sample
    repository.addSampleToPrototype(prototypeId, "uri3", "crop3")

    // Verify
    val updatedPrototype = repository.getPrototypeById(prototypeId)!!
    assertEquals(3, updatedPrototype.sampleCount)
    assertNotEquals(originalPrototype.embedding, updatedPrototype.embedding)
}
```

### Integration Tests

```kotlin
@Test
fun `complete few-shot tag creation flow`() = runTest {
    // 1. Create prototype with 3 samples
    val prototypeId = repository.createPrototype(
        name = "Test Person",
        color = 0xFF0000,
        samples = listOf(
            "content://media/1" to """{"left":0,"top":0,"width":100,"height":100}""",
            "content://media/2" to """{"left":0,"top":0,"width":100,"height":100}""",
            "content://media/3" to """{"left":0,"top":0,"width":100,"height":100}"""
        )
    )

    // 2. Verify prototype created
    val prototype = repository.getPrototypeById(prototypeId)
    assertNotNull(prototype)
    assertEquals("Test Person", prototype?.name)
    assertEquals(3, prototype?.sampleCount)

    // 3. Verify samples stored
    val samples = repository.getSamplesForPrototype(prototypeId).first()
    assertEquals(3, samples.size)

    // 4. Add another sample
    repository.addSampleToPrototype(
        prototypeId,
        "content://media/4",
        """{"left":0,"top":0,"width":100,"height":100}"""
    )

    // 5. Verify re-computed
    val updatedPrototype = repository.getPrototypeById(prototypeId)
    assertEquals(4, updatedPrototype?.sampleCount)

    // 6. Delete prototype
    repository.deletePrototype(prototypeId)

    // 7. Verify cascade delete
    val deletedPrototype = repository.getPrototypeById(prototypeId)
    assertNull(deletedPrototype)
    val deletedSamples = repository.getSamplesForPrototype(prototypeId).first()
    assertTrue(deletedSamples.isEmpty())
}

@Test
fun `search with few-shot prototype returns relevant results`() = runTest {
    // Setup: Create prototype for "dog"
    val dogPrototypeId = repository.createPrototype(
        name = "My Dog",
        color = 0xFF0000,
        samples = listOf(
            // URIs k obr√°zk≈Øm psa
        )
    )

    // Execute search
    val dogPrototype = repository.getPrototypeById(dogPrototypeId)!!
    val results = imageStore.search(dogPrototype.embedding, threshold = 0.2f)

    // Verify
    assertTrue(results.isNotEmpty())
    // Mƒõly by b√Ωt obr√°zky psa
}
```

### UI Tests

```kotlin
@Test
fun `user can create few-shot tag`() {
    // Launch app
    composeTestRule.setContent { App() }

    // Navigate to Few-Shot Tags tab
    composeTestRule.onNodeWithText("Few-Shot Tags").performClick()

    // Click "New Tag"
    composeTestRule.onNodeWithText("+ New Tag").performClick()

    // Fill name
    composeTestRule.onNodeWithTag("nameInput").performTextInput("Test Person")

    // Select category
    composeTestRule.onNodeWithTag("categorySelector").performClick()
    composeTestRule.onNodeWithText("Person").performClick()

    // Add 3 samples (mock)
    repeat(3) {
        composeTestRule.onNodeWithText("Pick from Gallery").performClick()
        // Mock image picker result
        composeTestRule.waitForIdle()
    }

    // Create tag
    composeTestRule.onNodeWithText("Create Tag").performClick()

    // Verify tag appears in list
    composeTestRule.onNodeWithText("Test Person").assertExists()
}
```

## üéì Best Practices & Tips

### 1. Poƒçet Samplu

```
‚úÖ Doporuƒçeno: 5-10 samplu
- 5 samplu: Minimum pro solidn√≠ prototype
- 7-8 samplu: Sweet spot (diversity vs. noise)
- 10+ samplu: Diminishing returns, ale po≈ô√°d OK

‚ùå Nedoporuƒçeno:
- 1-2 samples: P≈ô√≠li≈° m√°lo, prototype bude overfitted
- 20+ samples: Zbyteƒçn√©, nep≈ôid√°v√° p≈ôesnost
```

### 2. Kvalita Samplu

```
‚úÖ Dobr√© samples:
- R≈Øzn√© √∫hly (frontal, profil, 3/4)
- R≈Øzn√© osvƒõtlen√≠ (denn√≠, umƒõl√©, backlit)
- R≈Øzn√© v√Ωrazy (√∫smƒõv, neutr√°ln√≠, v√°≈æn√Ω)
- Podobn√° vzd√°lenost od kamery
- Clear, sharp images

‚ùå ≈†patn√© samples:
- V≈°echny stejn√Ω √∫hel
- Rozmazan√©/neostr√°
- ƒå√°steƒçnƒõ zakryt√© (ruka p≈ôed obliƒçejem)
- P≈ô√≠li≈° mal√© (< 64x64 px)
- P≈ô√≠li≈° r≈Øznorod√© vzd√°lenosti (closeup + daleko)
```

### 3. Naming Convention

```
‚úÖ Dobr√© n√°zvy:
- Konkr√©tn√≠: "Barunka", "Jonasek", "Moje auto"
- Kr√°tk√©: < 15 znak≈Ø
- Bez speci√°ln√≠ch znak≈Ø
- CamelCase nebo prost√Ω text

‚ùå ≈†patn√© n√°zvy:
- P≈ô√≠li≈° obecn√©: "Person1", "Face"
- P≈ô√≠li≈° dlouh√©: "Moje dcera Barunka kter√° m√° r√°da psy"
- Se speci√°ln√≠mi znaky: "Barunka#2023"
```

### 4. Category Guidelines

```
Person:
- Obliƒçeje lid√≠
- Cel√© postavy konkr√©tn√≠ch osob

Object:
- Auta, kola, hraƒçky
- Specifick√© objekty kter√© vlastn√≠te

Scene:
- M√≠sta (kuchynƒõ, ob√Ωv√°k, zahrada)
- Krajiny (hory, les, pl√°≈æ)

Style:
- Fotografick√Ω styl (ƒçernob√≠l√©, vintage)
- Kompozice (makro, panorama)
```

### 5. Performance Tips

```kotlin
// ‚úÖ Dobr√° praxe: Batch processing
suspend fun createPrototypeBatch(samples: List<Sample>) {
    withContext(Dispatchers.IO) {
        val embeddings = samples.map { sample ->
            async { extractEmbedding(sample) }
        }.awaitAll()

        savePrototype(embeddings)
    }
}

// ‚ùå ≈†patn√° praxe: Sequential processing
suspend fun createPrototypeSequential(samples: List<Sample>) {
    val embeddings = samples.map { sample ->
        extractEmbedding(sample) // ƒåek√° na ka≈æd√Ω embedding
    }
    savePrototype(embeddings)
}
```

### 6. User Feedback

```
P≈ôi vytv√°≈ôen√≠ prototypu:
‚úÖ "Extracting embeddings... (2/5)"
‚úÖ Progress bar
‚úÖ "Computing average..."
‚úÖ "Done! Created prototype 'Barunka'"

P≈ôi vyhled√°v√°n√≠:
‚úÖ "Searching with: Barunka + v lese"
‚úÖ Show combined chips
‚úÖ "Found 47 results (avg similarity: 82%)"
```

## üîÆ Budouc√≠ roz≈°√≠≈ôen√≠

### 1. Transfer Learning

```
M√≠sto pr≈Ømƒõrov√°n√≠ embedding≈Ø natr√©novat mal√Ω adapt√©r:

Input: CLIP embedding (768 dim)
   ‚Üì
Dense(512, ReLU)
   ‚Üì
Dense(256, ReLU)
   ‚Üì
Output: Refined embedding (768 dim)

Tr√©nov√°n√≠:
- Positive pairs: (sample, prototype)
- Negative pairs: (sample, other_prototype)
- Contrastive loss

Benefit: Lep≈°√≠ generalizace ne≈æ simple averaging
N√°roƒçnost: Pot≈ôeba 100+ samplu, GPU
```

### 2. Online Learning

```
Pr≈Øbƒõ≈æn√© vylep≈°ov√°n√≠ prototypu:

User vyhled√° "Barunka" ‚Üí 50 results
User vybere 5 obr√°zk≈Ø jako "correct"
   ‚Üì
System:
1. Extract embeddings z correct results
2. Blend do existuj√≠c√≠ho prototype (weighted average)
3. Re-compute prototype
4. Improve future searches

Benefit: Prototype se uƒç√≠ z user feedback
```

### 3. Hierarchick√© Prototypes

```
Person
‚îú‚îÄ‚îÄ Barunka
‚îÇ   ‚îú‚îÄ‚îÄ Barunka_closeup
‚îÇ   ‚îú‚îÄ‚îÄ Barunka_fullbody
‚îÇ   ‚îî‚îÄ‚îÄ Barunka_profile
‚îú‚îÄ‚îÄ Jonasek
‚îî‚îÄ‚îÄ Amily

Object
‚îú‚îÄ‚îÄ Cars
‚îÇ   ‚îú‚îÄ‚îÄ My_Car
‚îÇ   ‚îî‚îÄ‚îÄ Red_Cars
‚îî‚îÄ‚îÄ Bikes

Benefit: Organizace, inheritance embedding≈Ø
```

### 4. Multi-Modal Prototypes

```
M√≠sto jen image embeddings kombinovat v√≠ce modalit:

Prototype "Barunka":
‚îú‚îÄ‚îÄ Image embeddings (obliƒçej)
‚îú‚îÄ‚îÄ Text description: "blond hair, blue eyes, 5 years old"
‚îú‚îÄ‚îÄ Location: GPS coordinates domova
‚îú‚îÄ‚îÄ Time: typicky fotky 15:00-18:00
‚îî‚îÄ‚îÄ Co-occurrence: ƒçasto s "Jonasek", "zahrada"

Search: "Barunka" ‚Üí kombinuje v≈°echny modality
Benefit: Mnohem p≈ôesnƒõj≈°√≠ v√Ωsledky
```

### 5. Social Features

```
- Share prototypes mezi u≈æivateli
- Public prototype marketplace ("Celebrity Faces", "Car Brands")
- Collaborative prototypes (rodina p≈ôid√°v√° samples)
- Rating system pro prototypes
```

## üìö References & Resources

### Academic Papers

1. **Prototypical Networks** (Snell et al., 2017)
   - https://arxiv.org/abs/1703.05175
   - Z√°klad few-shot learning s prototypes

2. **CLIP** (Radford et al., 2021)
   - https://arxiv.org/abs/2103.00020
   - Multi-modal embeddings

3. **Matching Networks** (Vinyals et al., 2016)
   - https://arxiv.org/abs/1606.04080
   - Few-shot learning p≈ô√≠stup

### Code Examples

```kotlin
// P≈ô√≠klad pou≈æit√≠ v aplikaci:

// 1. Create few-shot tag
val barunkaId = fewShotRepository.createPrototype(
    name = "Barunka",
    color = 0xFF9C27B0.toInt(),
    samples = listOf(
        "content://media/1" to """{"left":100,"top":200,"width":300,"height":300}""",
        "content://media/5" to """{"left":150,"top":250,"width":280,"height":280}""",
        "content://media/12" to """{"left":120,"top":180,"width":320,"height":320}""",
        // ... 5-10 samples total
    ),
    category = "person"
)

// 2. Search using prototype
val barunkaPrototype = fewShotRepository.getPrototypeById(barunkaId)!!
val textEmbedding = textEmbedder.embed("v lese")

val combinedEmbedding = combineEmbeddingsSimple(
    prototypes = listOf(barunkaPrototype.embedding),
    textEmbedding = textEmbedding
)

val results = imageStore.search(combinedEmbedding, threshold = 0.2f)

// 3. Multi-prototype search
val jonasekPrototype = fewShotRepository.getPrototypeById(jonasekId)!!

val multiPrototypeResults = multiVectorSearch(
    imageStore = imageStore,
    prototypes = listOf(barunkaPrototype.embedding, jonasekPrototype.embedding),
    textEmbedding = textEmbedder.embed("na dovolen√©"),
    threshold = 0.2f,
    combineMode = CombineMode.AND // Must contain BOTH Barunka and Jonasek
)
```

## üöÄ Implementaƒçn√≠ checklist

### Datab√°ze
- [ ] FewShotPrototypeEntity
- [ ] FewShotSampleEntity
- [ ] FewShotPrototypeDao
- [ ] FewShotSampleDao
- [ ] FewShotRepository
- [ ] Room migration
- [ ] Unit testy

### Core Logic
- [ ] computeAverageEmbedding()
- [ ] combineEmbeddingsSimple()
- [ ] combineEmbeddingsWeighted()
- [ ] multiVectorSearch() (optional)
- [ ] extractEmbeddingFromCrop()
- [ ] Integration testy

### UI - Few-Shot Tags Screen
- [ ] FewShotTagsScreen
- [ ] CreateFewShotTagDialog
- [ ] FewShotPrototypeDetailScreen
- [ ] FewShotSampleGrid
- [ ] FewShotTagsViewModel
- [ ] UI testy

### UI - Search Integration
- [ ] FewShotChips component
- [ ] Autocomplete pro few-shot tags
- [ ] Combined search preview
- [ ] Update SearchViewModel
- [ ] Update SearchScreen
- [ ] Integration testy

### Advanced Features (Optional)
- [ ] Export/Import prototypes
- [ ] Auto-clustering
- [ ] Confidence scoring
- [ ] Negative prototypes
- [ ] Analytics

### Polish
- [ ] Empty states
- [ ] Error states
- [ ] Loading indicators
- [ ] Onboarding tutorial
- [ ] Performance optimization
- [ ] Accessibility
- [ ] Documentation

---

**Autor:** Jaroslav + Claude Code
**Datum:** 2025-01-28
**Verze:** 1.0
**Status:** Design Document - P≈ôipraveno k implementaci
